C51 COMPILER V9.54   MAIN                                                                  12/29/2019 01:21:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\GSM;.\Ultrasonic;.\XY-V17
                    -B;.\DS18B20;.\uart;.\delay;.\LED;.\BH1750;.\DHT11) DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) OBJECT(..\Output\main.o
                    -bj)

line level    source

   1          #include "config.h"
   2          #include "delay.h"
   3          #include "uart.h"
   4          #include "led.h"
   5          #include "GSM.h"
   6          #include "Ultrasonic.h"
   7          #include "ds18b20.h"
   8          #include "BH1750.h"
   9          #include "XY-V17B.h"
  10          #include "dht11.h"
  11          
  12          extern unsigned char flag_temper;
  13          extern unsigned char  aaa[];
  14          extern unsigned char  times_r[25];
  15          unsigned char RX_Buffer[68] = "00000000000000000000000000000000000000000000";
  16          unsigned char RX_Count = 0;
  17          
  18          /*************  本地常量声明    **************/
  19          
  20          sbit K1  = P2^0;        //温度播报
  21          sbit K2  = P2^1;        //距离播报
  22          sbit K3  = P2^2;        //时间播报
  23          sbit K4  = P2^3;        //一键求救
  24          
  25          
  26          
  27          
  28          uchar LED_MODE_C = 0;
  29          uchar LED_MODE_G = 0;
  30          
  31          /*******************************************************************************
  32          * 函数名 : main 
  33          * 描述   : 主函数
  34          * 输入   : 
  35          * 输出   : 
  36          * 返回   : 
  37          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  38                                             为9600方可使用。 
  39          *******************************************************************************/
  40          void main(void)
  41          {
  42   1      //      unsigned int    i;
  43   1              unsigned char   tempdat[8];                     //显示缓冲
  44   1              unsigned int    tempda1 = 0;            //温度
  45   1              unsigned int    tempdisda1=0;           //距离
  46   1              unsigned int    tempMultiple=0;         //光强
  47   1              unsigned int    tick=0;                         
  48   1              unsigned int    led_tick=0;
  49   1              unsigned char   year    =0,
  50   1                                              month   =0,
  51   1                                              day             =0,
  52   1                                              hour    =0,
  53   1                                              minute  =0;
C51 COMPILER V9.54   MAIN                                                                  12/29/2019 01:21:20 PAGE 2   

  54   1              unsigned char LED_ON_OFF=0;
  55   1              AUXR = AUXR|0x40;  // T1, 1T Mode
  56   1              Uart1Init();            //初始化两个串口9600
  57   1              GSM_INIT();             //GSM模块初始化
  58   1              UART1_SendString("1\r\n");
  59   1              while(1)
  60   1              {
  61   2                      tick++;
  62   2                      led_tick++;
  63   2                      if(tick % 999 == 0 )
  64   2                      {
  65   3                              tempdisda1 = Conut();
  66   3                              if(tempdisda1<15)
  67   3                              {
  68   4                                      LED_MODE_C = 1;   //常量
  69   4                              }
  70   3                              else if(tempdisda1>=15&& tempdisda1<30)
  71   3                              {
  72   4                                      LED_MODE_C= 2;  //闪烁
  73   4                              }
  74   3                              else
  75   3                                      LED_MODE_C = 0;
  76   3                      }
  77   2                      if(tick % 3999 == 0 )   //温度检测
  78   2                      {
  79   3                              tempda1 = receive();
  80   3                      }
  81   2                      if(tick % 6999 == 0 )           //光强检测
  82   2                      {
  83   3                              Multiple_read_BH1750();
  84   3                              tempMultiple = GetMultipleDat();
  85   3                              if( tempMultiple <20)
  86   3                              {
  87   4                                      LED_MODE_G = 1;
  88   4                              }
  89   3                              else
  90   3                              {
  91   4                                      LED_MODE_G = 0;
  92   4                              }
  93   3                      }
  94   2                      if(tick % 4699 == 0 )
  95   2                      {
  96   3                              SendCMD_TIME();
  97   3                      }
  98   2                      if(tick % 5699==0)
  99   2                      {
 100   3                              if(GET_time()==1 )
 101   3                              {
 102   4                                      //UART1_SendString("ok\r\n");
 103   4                              }
 104   3                              else
 105   3                                      ;
 106   3                                      //UART1_SendString("error\r\n");
 107   3                      }
 108   2                      if( tick <= 3000)                       //显示距离
 109   2                      {
 110   3                              tempdat[0] = tempdisda1%10;
 111   3                              tempdat[1] = tempdisda1%100/10;
 112   3                              tempdat[2] = tempdisda1%1000/100;
 113   3                              tempdat[3] = 0;
 114   3                              tempdat[4] = 0;
 115   3                              tempdat[5] = 0;
C51 COMPILER V9.54   MAIN                                                                  12/29/2019 01:21:20 PAGE 3   

 116   3                              tempdat[6] = 0;
 117   3                              tempdat[7] = 16;
 118   3                              display( tempdat );     
 119   3                      }
 120   2                      else if(tick > 3000 && tick <= 6000)    //显示温度
 121   2                      {
 122   3                              tempdat[0] = tempda1%10/1;
 123   3                              tempdat[1] = tempda1%100/10;
 124   3                              tempdat[2] = tempda1%1000/100;
 125   3                              tempdat[3] = 0;
 126   3                              tempdat[4] = 0;
 127   3                              tempdat[5] = 0;
 128   3                              tempdat[6] = 16;
 129   3                              tempdat[7] = 0;
 130   3                              display( tempdat );
 131   3                      }
 132   2                      else if(tick > 6000 && tick <= 9000)    //显示光强
 133   2                      {
 134   3                              tempdat[0] = tempMultiple%10/1;
 135   3                              tempdat[1] = tempMultiple%100/10;
 136   3                              tempdat[2] = tempMultiple%1000/100;
 137   3                              tempdat[3] = tempMultiple%10000/1000;
 138   3                              tempdat[4] = 0;
 139   3                              tempdat[5] = 16;
 140   3                              tempdat[6] = 0;
 141   3                              tempdat[7] = 0;
 142   3                              display( tempdat );
 143   3                      }
 144   2                      else if(tick > 9000 && tick <= 12000)//显示日期
 145   2                      {
 146   3                              tempdat[0] = times_r[8]-0x30;
 147   3                              tempdat[1] = times_r[7]-0x30;
 148   3                              tempdat[2] = 16;
 149   3                              tempdat[3] = times_r[5]-0x30;
 150   3                              tempdat[4] = times_r[4]-0x30;
 151   3                              tempdat[5] = 16;
 152   3                              tempdat[6] = times_r[2]-0x30;
 153   3                              tempdat[7] = times_r[1]-0x30;
 154   3                              display( tempdat );
 155   3                      }
 156   2                      else if(tick > 12000 && tick <= 15000)//显示时间
 157   2                      {
 158   3      //                      hour = times_r[14]+times_r[13]*10;
 159   3      //                      minute = times_r[11]+times_r[10]*10;
 160   3                              tempdat[0] = times_r[14]-0x30;
 161   3                              tempdat[1] = times_r[13]-0x30;
 162   3                              tempdat[2] = 16;
 163   3                              tempdat[3] = times_r[11]-0x30;
 164   3                              tempdat[4] = times_r[10]-0x30;
 165   3                              tempdat[5] = 16;
 166   3                              tempdat[6] = 16;
 167   3                              tempdat[7] = 16;
 168   3                              display( tempdat );
 169   3                      }
 170   2                      if(tick>15000)
 171   2                      {
 172   3                              tick = 0;
 173   3                      }
 174   2                      
 175   2                      if(LED_MODE_G == 1 || LED_MODE_C==1 )   ///常亮
 176   2                      {
 177   3                              RUNING_LED=0;
C51 COMPILER V9.54   MAIN                                                                  12/29/2019 01:21:20 PAGE 4   

 178   3                              if(LED_MODE_G !=1)
 179   3                                      BEEP = 1;
 180   3                      }
 181   2                      else if(LED_MODE_C == 2 && LED_MODE_G == 0)
 182   2                      {
 183   3                              if(led_tick>900)
 184   3                              {
 185   4                                      RUNING_LED=0;
 186   4                                      BEEP = 1;
 187   4                              }
 188   3                              else
 189   3                              {
 190   4                                      RUNING_LED=1;
 191   4                                      BEEP = 0;
 192   4                              }
 193   3                      }
 194   2                      else            //关闭LED灯光
 195   2                      {
 196   3                              RUNING_LED = 1;
 197   3                              BEEP       = 0;
 198   3                      }
 199   2                      if(led_tick>2000)
 200   2                      {
 201   3                              led_tick=0;
 202   3                      }
 203   2                      
 204   2                      if(K1 == 0)             //温度播报
 205   2                      {
 206   3                              delay5ms();
 207   3                              if(K1 == 0)
 208   3                              {
 209   4                                      while( !K1 ); 
 210   4                                      SOURCEvoice_Tempriture(tempda1);
 211   4                              //      SOURCEvoice_Tempritu re( 15);
 212   4                              }
 213   3                      }
 214   2                      if(K2 == 0)             //距离播报
 215   2                      {
 216   3                              delay5ms();
 217   3                              if(K2 == 0)
 218   3                              {
 219   4                                      while( !K2 ); 
 220   4                                      SOURCEvoice_Distance(tempdisda1);
 221   4                              //      SOURCEvoice_Distance(5);
 222   4                              }
 223   3                      }
 224   2                      if(K3 == 0)             //时间播报
 225   2                      {
 226   3                              delay5ms();
 227   3                              if(K3 == 0)
 228   3                              {
 229   4                                      while( !K3 ); 
 230   4                                      SOURCEvoiceTime((times_r[10]-0X30)*10+(times_r[11]-0X30),(times_r[13]-0X30)*10+(times_r[14]-0X30));
 231   4                                      //SOURCEvoiceTime(22,5);
 232   4                              }
 233   3                       }
 234   2                      if(K4 == 0)                     //一键发送短信
 235   2                      {
 236   3                              delay5ms();
 237   3                              if(K4 == 0)
 238   3                              {
 239   4                                      while(!K4); 
C51 COMPILER V9.54   MAIN                                                                  12/29/2019 01:21:20 PAGE 5   

 240   4                                      Send_SeekhelpMSG();
 241   4                              }
 242   3                      }
 243   2                      delay5us();
 244   2              }
 245   1      }
 246          
 247          
 248          /*******************************************************************************
 249          * 函数名 : Uart2 
 250          * 描述   : 串口2中断服务入口函数
 251          * 输入   : 
 252          * 输出   : 
 253          * 返回   : 
 254          * 注意   : 
 255          *******************************************************************************/
 256          void RECEIVE_DATA(void) interrupt 4                     
 257          { 
 258   1              unsigned char temp = 0;
 259   1              ES=0;
 260   1              if (RI)
 261   1          {
 262   2                      temp = SBUF;
 263   2                      RI = 0;
 264   2              }
 265   1              ES=1; 
 266   1      }
 267          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1101    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =     71      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
