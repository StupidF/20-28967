#include "ds18b20.h"
#include "delay.h"
#include "stdio.h"
#include "intrins.h"


sbit DS18B20_DQ = P1^7;  //DS18B20 IO设置
 
unsigned char flag_temper = 0;  //定义变量
 



//****************************************************
//DS18B20初始化
//****************************************************
bit DS18B20_Init()
{
	bit Flag_exist = 1;		//初始化结果标志
	
	DS18B20_DQ = 1;			 	//单片机管脚电平拉高，以释放总线（图中步骤1）
	delay2us();			  	 	//延时>1us，执行2us
 
	DS18B20_DQ = 0;	    	//单片机电平拉低以启动DS18B20初始化（图中步骤2）
	delay500us();		     	//延时480~960us执行500us	
 
	DS18B20_DQ = 1;				//释放总线（图中步骤3）
	delay60us();					//延时15~60us，执行60us保险起见加个NOP
	_nop_();
	
	Flag_exist = DS18B20_DQ; //将DS18B20输出状态读到初始化结果状态标志中（图中步骤4）
	
	delay500us();					//从单片机输出电平拉高时（步骤3）算起，总时长不得小于480us（执行500uS加上之前的60us及指令执行周期总执时时延大于560us）
 
	return Flag_exist;		//返回初始化结果标志，后面代码中用于判断初始化是否成功	
}
 
//****************************************************
//DS18B20写1字节
//****************************************************
void DS18B20_Write_Byte( unsigned char dat)
{
	unsigned char i;
	for( i = 0 ; i < 8 ; i++ )
	{
		DS18B20_DQ = 0; //单片机拉低启动DS18B20读/写时序（前面必须有初始化操作）（步骤2）
		delay2us();			//延时>1us（执行2us）
		
		DS18B20_DQ = dat&0x01;	//DS18B20先写指令时要求先低位，该指令为取出写数据的最低bit送给单片机总线管脚输出 （步骤3）
		dat >>= 1;			//将写的数据进行右移一位，将原先的第二位放置到末位，为下个循环过程取值做准备
 
		delay60us();	//单片机总线输出保持时间需要保证从总线拉低开始（步骤2）至写一个字节指令结束总时长大于60us,执行（2us+60us+指令时长大于62us）(步骤4)
		_nop_();      //保险起见加个机器周期，可有可无
		
		DS18B20_DQ = 1;		//指令写完后要释放总线  （步骤5）
		delay2us();			//写下一个BIT前必须间隔1us以上（执行2us) 
	}		
}
 
//****************************************************
//DS18B20读1字节
//****************************************************
unsigned char DS18B20_Read_Byte( )
{
	unsigned char dat,i;
	for( i = 0 ; i < 8 ; i++ )
	{
		DS18B20_DQ = 0;	//单片机拉低并保持1us以上（执行2us）启动DS18B20读/写时序（前面必须有初始化操作）（步骤2）
		delay2us();			//延时2us
				
		DS18B20_DQ = 1;		//单片机输出高电平，拉高总线即释放总线 （步骤3）
		delay10us();			//从步骤2开始，至释放数据线（即此处）不得超过15us，并且在快到15us时单片机进行总线数据读取，此处延时必须精确（到此处总延时2+10+两条指令略大于12us）
 
		dat >>= 1;        //将前面取到的bit左移，第一次为空转 
		if( DS18B20_DQ == 1) //总线取值操作 （步骤4）
		{
			dat |= 0X80;  
		}
		else
		{
			dat &= 0x7f;
		}
 
		delay60us();	//读时隙总时长不得小于60us（执行12us+60us+指令周期大于72us，满足大于60us要求）（步骤5）			
	}
	return dat;		
}
 
//**********************************************************
//读取温度函数，返回温度的绝对值，并标注flag_temper，flag_temper=1表示负，flag_temper=0表示正
//**********************************************************
unsigned int Get_temp(void)         //读取温度值 
{  
	float tt;
	unsigned int a=0,b=0;
	unsigned int temp=0;
	if( DS18B20_Init() == 0 )              //初始化
	{
		DS18B20_Write_Byte(0xcc);          //忽略ROM指令
		DS18B20_Write_Byte(0x44);          //温度转换指令
	
		if( DS18B20_Init() == 0 )              //初始化
		{
			DS18B20_Write_Byte(0xcc);          //忽略ROM指令
			DS18B20_Write_Byte(0xbe);          //读暂存器指令
			a = DS18B20_Read_Byte();           //读取到的第一个字节为温度LSB
			b = DS18B20_Read_Byte();           //读取到的第一个字节为温度MSB
			temp = b;                      //先把高八位有效数据赋于temp
			temp <<= 8;                    //把以上8位数据从temp低八位移到高八位
			temp = temp|a;                //两字节合成一个整型变量
			
//			if(temp>0xfff)
//			{
//				flag_temper=1;				//温度为负数
//				temp=(~temp)+1;
//			}
//			else
//			{																			   
//				flag_temper=0;				//温度为正或者0
//			}
			
			tt = temp*0.0625;              //得到真实十进制温度值
			                                //因为DS18B20可以精确到0.0625度
			                                //所以读回数据的最低位代表的是0.0625度
			temp = (unsigned int)(tt*10);               //放大十倍
			                                //这样做的目的将小数点后第一位也转换为可显示数字
		                              	    //同时进行一个四舍五入操作。
		}
	}
	return temp;   //注意返回值是实际值的十倍（如37.5度，返回值为375），目的是为在INT型中取小数据点后1位，
}

